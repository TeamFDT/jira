package com.conedog.math{	import flash.display.DisplayObject;	import flash.geom.Matrix;	import flash.geom.Point;	public class Math2	{				public static const PI_2			:Number = Math.PI * 2;				//_________________R A N D O M   F U N C T I O N S				/* R A N D O M :		returns a random number between two specified values */				public static function random(from:Number = 0, to:Number = 1):Number		{			return Math.random()*(to-from) + from;		}				/* R A N D O M   I N T:		returns a random number whole number between two specified values */				public static function randomInt(from:Number = 0, to:Number = 1):int		{			to += 1;			return Math.floor(Math.random()*(to-from) + from);		}				/* R A N D O M   P L U S   M I N U S:		randomly returns either plus or minus 1 */				public static function randomPlusMinus(chance:Number = 0.5):int		{			return (Math.random() > chance) ? -1 : 1;		}				/* R A N D O M   B O O L:		randomly returns either true or false */				public static function randomBool(chance:Number = 0.5):Boolean		{			return (Math.random() < chance) ? true : false;		}								//_________________R O U N D I N G   F U N C T I O N S				/* R O U N D:		rounds a number to the specifed decimal place */				public static function round(n:Number, decimalPlaces:int = 0):Number		{			var shift:int = Math.pow(10, decimalPlaces);			return Math.round(n * shift)/shift;		}				/* F L O O R:		floors a number to the specifed decimal place */				public static function floor(n:Number, decimalPlaces:int = 0):Number		{			var shift:int = Math.pow(10, decimalPlaces);			return Math.floor(n * shift)/shift;		}				/* C E I L:		ceils a number to the specifed decimal place */				public static function ceil(n:Number, decimalPlaces:int = 0):Number		{			var shift:int =  Math.pow(10, decimalPlaces);			return Math.ceil(n * shift)/shift;		}								//_________________C O N V E R T I N G   F U N C T I O N S				public static function cap(value:Number, min:Number = 0, max:Number = 1):Number		{			if(value < min)value = min;			if(value > max)value = max;						return value;		}						/* C O N V E R T:		converts a number within one range of values to another */				public static function convert(val:Number, inputMin:Number, inputMax:Number, outputMin:Number, outputMax:Number):Number		{			/*			var inputRange = inputMax - inputMin						var inputFraction = (val - inputMin)/inputRange						var outputRange = outputMax - outputMin						var output = (outputRange * inputFraction) + outputMin						return output			*/						return ((outputMax - outputMin) * ((val - inputMin)/(inputMax - inputMin))) + outputMin;		}				/* C O N V E R T   L I M I T:		converts a number within one range of values to another but keeps		the returned value within the min and max output */				public static function convertLimit(val:Number, inputMin:Number, inputMax:Number, outputMin:Number, outputMax:Number):Number		{						return Math.max(outputMin, Math.min(outputMax, ((outputMax - outputMin) * ((val - inputMin)/(inputMax - inputMin))) + outputMin));		}				public static function sign(num:Number):Number 		{			if (num >= 0) 			{				return 1;			} 			else			{				return -1;			}		}				/* SMALLEST ANGLE:		get smallest angle from one bearing to another		*/				public static function smallestAngle(angle:Number, targetAngle:Number):Number		{						// STANDARD						var difference1:Number = targetAngle - angle;						// "ROUND THE HORN" CLOCKWISE / POSITIVE 						var difference2:Number = (targetAngle + (Math.PI * 2)) - angle;									// "ROUND THE HORN" ANTI-CLOCKWISE / NEGATIVE 						var difference3:Number = (targetAngle - (Math.PI * 2)) - angle;						// GET SHORTEST								var absDifference1:Number = Math.abs(difference1);			var absDifference2:Number = Math.abs(difference2);			var absDifference3:Number = Math.abs(difference3);						var difference:Number = difference1;						if (absDifference2 < absDifference1 && absDifference2 < absDifference3)			{				difference = difference2;			}			else if (absDifference3 < absDifference1 && absDifference3 < absDifference2)			{				difference = difference3;			}						return difference;		}				public static function smallestCirculerDistance(value:Number, destinationValue:Number, distance:Number):Number		{						// STANDARD						var difference1:Number = destinationValue - value;						// "ROUND THE HORN" CLOCKWISE / POSITIVE 						var difference2:Number = (destinationValue + distance) - value;									// "ROUND THE HORN" ANTI-CLOCKWISE / NEGATIVE 						var difference3:Number = (destinationValue - distance) - value;						// GET SHORTEST								var absDifference1:Number = Math.abs(difference1);			var absDifference2:Number = Math.abs(difference2);			var absDifference3:Number = Math.abs(difference3);						var difference:Number = difference1;						if (absDifference2 < absDifference1 && absDifference2 < absDifference3)			{				difference = difference2;			}			else if (absDifference3 < absDifference1 && absDifference3 < absDifference2)			{				difference = difference3;			}						return difference;		}				/* LIMIT:		limits the absolute value of target to max, while retaining the sign */				public static function limit(target:Number, max:Number):Number		{			var output:Number = Math.min(Math.abs(target), max);													   			output *= Math2.sign(target);						return output;					}				/* LIMIT RADIANS 		limit angle to +/- PI */				public static function limitRadians(angle:Number):Number		{			if (angle > Math.PI)			{				angle -= Math.PI * 2;			}			else if (angle < -Math.PI)			{				angle += Math.PI * 2;			}						return angle;		}				/*HYP		return distance between 2 points*/				public static function hyp(x1:Number, y1:Number, x2:Number, y2:Number):Number 		{			var dx:Number = x1 - x2;			var dy:Number = y1 - y2;						return Math.sqrt((dx*dx)+(dy*dy));		}				public static function hyp2(dx:Number, dy:Number):Number 		{			return Math.sqrt((dx*dx)+(dy*dy));		}				public static function closerThan(x1:Number, y1:Number, x2:Number, y2:Number, distance:Number):Boolean 		{			var dx:Number = x1 - x2;			var dy:Number = y1 - y2;						return (dx*dx)+(dy*dy) < distance * distance;		}				public static function rotateAroundPoint(object:DisplayObject, rotation:Number = 0, x:int = 0, y:int = 0):void		{			var point:Point = new Point();						var m:Matrix = new Matrix();			m.tx -= x;			m.ty -= y;			m.rotate(rotation);			m.tx += x;			m.ty += y;						point = m.transformPoint(point);			object.transform.matrix = m;						//object.x = m.tx;			//object.y = m.ty;						//object.rotation = rotation;		}				public static function modulus(n:Number, modulus:Number = 0):Number		{			var val:Number = n % modulus;			if(val < 0)val += modulus;			return val;		}	}}