package com.kurst.utils {	import flash.geom.Point;	/**	 * @author karimbeyrouti	 */	public class NumberUtils {		/*		 * @detail		 * @access		 * @param		 * @param		 * @return		 */		public static function isEven(num : int) : Boolean {			return ((num & 1) == 0)		}		/*		 * @detail		 * @access		 * @param		 * @param		 * @return		 */		public static function isOdd(num : int) : Boolean {			return !NumberUtils.isEven(num);		}		/*		 * @detail:  		 * @param: 		 * @param: 		 * @param: 		 * @return: 		 */		public static function randRange(minNum : Number, maxNum : Number, round : Boolean = false) : Number {			// TODO: randRange(minNum:Number, maxNum:Number, round:Boolean = false) - needs testing / QA			if (minNum < 0) {				var posMin : Number = (minNum * -1);				var range : Number = posMin + maxNum;				if (round)					return Math.floor(Math.random() * (range - 1)) - posMin;				return Math.random() * (range - 1) - posMin;			}			if (round)				return Math.floor(Math.random() * (maxNum - minNum + 1)) + minNum;			return Math.random() * (maxNum - minNum + 1) + minNum;		}		/*		 * @detail:  		 * @param: 		 * @param: 		 * @param: 		 * @return: 		 */		public static function flipCoin() : Boolean {			return ((NumberUtils.randomRange(2, 0)) < 1)		}		/*		 * @detail: Generate a random number within a specified range		 * @access: public static		 * @param: numIni => Number		 * @param: numEnd => Number		 * @return: Array		 */		public static function randomRange(minNum : Number, maxNum : Number) : Number {			// TODO: randomRange(minNum:Number, maxNum:Number):Number - needs testing / QA			// return ((Math.random() * (maxNum - minNum + 1)) + minNum);			return ((Math.random() * (maxNum - minNum )) + minNum);		}		/*		 * @detail: constraint a value between a min and a max 		 * @param: val => Number		 * @param: min => Number		 * @param: max => Number		 * @return: Number		 */		public static function constraint(val : Number, min : Number, max : Number) : Number {			if ( val < min ) return min			if ( val > max ) return max			return val;		}		/*		 * @detail:  		 * @param: 		 * @param: 		 * @param: 		 * @return: 		 */		public static function normalizeNumbers(list : Array, minVal : Number = NaN, maxVal : Number = NaN) : Array {			var min : Number = !isNaN(minVal) ? minVal : Math.min.apply(null, list);			var max : Number = !isNaN(maxVal) ? maxVal : Math.max.apply(null, list);			var len : int = list.length;			var result : Array = [];			for (var i : int = 0; i < len; i++)				result[i] = rangedToNormal(list[i], min, max)			return result;		}		/*		 * @detail:  		 * @param: 		 * @param: 		 * @param: 		 * @return: 		 */		public static function getMin(list : Array) : Number {			return Math.min.apply(null, list);		}		/*		 * @detail:  		 * @param: 		 * @param: 		 * @param: 		 * @return: 		 */		public static function getMax(list : Array) : Number {			return Math.max.apply(null, list);		}		/*		 * @detail:  		 * @param: 		 * @param: 		 * @param: 		 * @return: 		 */		public static function rangedToNormal(ranged : Number, min : Number, max : Number) : Number {			var rangeSize : Number = max - min;			return (ranged - min) / rangeSize;		}		/*		 * 		 * 	// var p:Point = getRandomBorderPoint(0, 0, Stage.width, Stage.height, 30, 30);		 * 				 * @detail:  		 * @param: 		 * @param: 		 * @param: 		 * @return: 		 */		public static function getRandomBorderPoint(x : Number, y : Number, w : Number, h : Number, maxXDiff : Number = NaN, maxYDiff : Number = NaN) : Point {			if ( isNaN(maxXDiff) ) maxXDiff = 0;			if ( isNaN(maxYDiff) ) maxYDiff = 0;			var p : Point = new Point();			if ( ( randomRange(-1, 0) ) < 0 ) {				// flip a coin				p.x = randomRange(x - maxXDiff, x + w + maxXDiff);				p.y = getNextAxisVal(p.x, x, w, y, h, maxYDiff);			} else {				p.y = randomRange(y - maxYDiff, y + h + maxYDiff);				p.x = getNextAxisVal(p.y, y, h, x, w, maxXDiff);			}			return p;		}		/*		 * @detail:  		 * @param: 		 * @param: 		 * @param: 		 * @return: 		 */		private static function getNextAxisVal(z : Number, d : Number, f : Number, j : Number, n : Number, max : Number) : Number {			if (z >= d && z <= d + f) {				return ( ( randomRange(-1, 0) ) < 0 ) ? randomRange(j - max, j) : randomRange(j + n, j + n + max);			}			return randomRange(j - max, j + n + max);		}	}}