/******************************************************************************************************************************************************************************** *  * Class Name  	: karimbeyrouti * Version 	  	: com.kurst.controls.gallery3d.renderer.GridRenderer * Description 	: Grid Renderer *  ******************************************************************************************************************************************************************************** *  * Author 		: Kb * Date 			: 27/05/09 *  ******************************************************************************************************************************************************************************** *  * METHODS *  * 		destroy() * 		setRenderData( a : Array ) : void * 		setGallerySettings( settings : GallerySettings ) : void * 		setRenderSettings( s : * ) : void * 		getRenderSettings( ) : * * 		render( selectedID : Number,  invalidate : Boolean = false ) : void * * EVENTS *  * 		Gallery3dEvent.SCROLL_COMPLETE *  ******************************************************************************************************************************************************************************** * **********************************************************************************************************************************************************************************/package com.kurst.controls.gallery3d.renderer {	import com.kurst.controls.gallery3d.settings.GallerySettings;	import com.kurst.controls.gallery3d.settings.StripSettings;	import com.kurst.events.Gallery3dEvent;	import com.kurst.pv3d.objects.PlaneX;	import com.kurst.utils.NumberUtils;	import flash.display.Stage;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;	import com.greensock.*	import com.greensock.events.*	import org.papervision3d.core.proto.CameraObject3D;	import org.papervision3d.events.InteractiveScene3DEvent;	import org.papervision3d.objects.DisplayObject3D;	public class StripRenderer extends GalleryRenderer implements IGalleryRenderer {		// ------------------------------------------------------------------------------------------------------------------------------------------------------------		private var _settings : GallerySettings;		private var _renderSettings : StripSettings		private var data : Array;		private var selectedID : Number;		private var prevrZ : Number = -1;		private var initFlag : Boolean = false;		private var selectedPlane : PlaneX;		private var targetDO : DisplayObject3D;		private var initCameraFlag : Boolean = false;		private var midPoint : Number = 0;		private var startDragXPos : Number = 0;		private var dragOffset : Number = 0;		private var unSelectedTargetXPos : Number = 0;		private var prevRollOverPlane : PlaneX;		private var _scrollMultiplier : int;		private var _scrollTimer : Timer;		private var stageWidth : Number = 0;		private var stageHeight : Number = 0;		// ------------------------------------------------------------------------------------------------------------------------------------------------------------		public function StripRenderer(settings : StripSettings) {			_renderSettings = settings			_scrollTimer = new Timer(60);			_scrollTimer.addEventListener(TimerEvent.TIMER, scrollLoop, false, 0, true);		}		// -PUBLIC-----------------------------------------------------------------------------------------------------------------------------------------------------		// ------------------------------------------------------------------------------------------------------------------------------------------------------------		//		// PPPPPP  UU   UU BBBBBB  LL      IIIIII  CCCCC		// PP   PP UU   UU BB   BB LL        II   CC   CC		// PPPPPP  UU   UU BBBBBB  LL        II   CC		// PP      UU   UU BB   BB LL        II   CC   CC		// PP       UUUUU  BBBBBB  LLLLLLL IIIIII  CCCCC		//		// ------------------------------------------------------------------------------------------------------------------------------------------------------------		// ------------------------------------------------------------------------------------------------------------------------------------------------------------		/**		 * @method destroy()		 * @tooltip		 * @param  		 */		override public function destroy() : void {			super.destroy()			_scrollTimer.stop()			_scrollTimer.removeEventListener(TimerEvent.TIMER, scrollLoop);			_scrollTimer = null;			// TweenMax.killAllDelayedCalls();			if ( data != null ) {				for ( var j : int = 0 ; j < data.length ; j++ ) {					var r : Object = data[j];					if ( r != null ) {						var pl : PlaneX = r.plane;						pl.removeEventListener(InteractiveScene3DEvent.OBJECT_PRESS, SelectPlane);						pl.removeEventListener(InteractiveScene3DEvent.OBJECT_OVER, OverPlane);						pl.removeEventListener(InteractiveScene3DEvent.OBJECT_OUT, OutPlane);					}				}			}			targetDO = null;			selectedPlane = null;			_settings = null;			data = null;			selectedID = undefined;			selectedRecord = null;		}		/**		 * @method render( sID : Number,  invalidate : Boolean = false ) : void		 * @tooltip		 * @param  		 */		override public function render(sID : Number, invalidate : Boolean = false) : void {			if ( selectedRecord != null )				TweenMax.killDelayedCallsTo(selectedRecord.plane)			if ( selectedRecord != null )				selectedRecord.plane.material.smooth = false;			selectedID = ( invalidate == true && selectedID == -1) ? -1 : sID			if ( selectedID != -1 ) {				var record : Object = data[ selectedID ];				// Record of new plane				selectedRecord = record;			} else if ( selectedID == -1 && selectedPlane != null && !invalidate ) {				unSelectedTargetXPos = selectedPlane.x;			}			var i : int = 0			// Loop - Counter			var rec : Object			// Loop - Record			var p : PlaneX			// Loop - Plane			var tweenTime : Number = _renderSettings.animationTime;			// Tween Duration			var easeFnc : Function = _renderSettings.animationEasingFunction			// Tween Easing			var itemCounter : int = 0;			var col : int = 0			// _renderSettings.cols // 0;			var row : int = _renderSettings.gridRows			var tx : Number, 			ta : Number, 			ty : Number, 			tz : Number, 			ts : Number			var rZ : Number			var calcDelay : Number = 0;			var l : int = data.length;			// Sine Test			var totalCols : Number = Math.round(data.length / _renderSettings.gridRows);			var degreeStep : Number = _renderSettings.cycleTotalDegrees / totalCols;			var currentSinDegs : Number = 0;			var sinZ : Number = 0;			var sinValue : Number = 0;			// ------------------------------------------------------------------------------			// reposition all plane / items on display			for ( i ; i < l ; i++ ) {				if ( !initFlag && !invalidate ) calcDelay += _renderSettings.animationInitialDrawTime;				// Animation Delay - Reposition Planes on initial RUN				rec = data[i];				// Reference current record				p = rec.plane;				// Reference cirrent plane				/*				var ca : CoreAsset 	= ( ( p.material as MovieMaterial ).movie as CoreAsset ) 				ca.thumbQuality = _renderSettings.thumbnailQuality; 				 */				// ROW / COL positional variable increments				if ( i % _renderSettings.gridRows == 0 ) {					col++;					currentSinDegs += degreeStep;					row = _renderSettings.gridRows;				}				p.visible = true;				// Make ALL planes visible				// ------------------------------------------------------------------------------				// Random Z Settings - Store the Random Z value in the d03d.extra object				rZ = ( _renderSettings.gridRandomZPosition > 0 || prevrZ != _renderSettings.gridRandomZPosition ) ? NumberUtils.randRange(0, _renderSettings.gridRandomZPosition, true) : rZ = 0;				if ( p.extra == null ) p.extra = new Object();				if ( p.extra.rZ == null || prevrZ != _renderSettings.gridRandomZPosition ) p.extra.rZ = rZ;				if ( p.extra.isOver == null ) p.extra.isOver = false;				// ------------------------------------------------------------------------------				// Selected Plane				if ( selectedID == rec._id && selectedID != -1  ) {					// 5/12/09					// if ( selectedID == rec._id ){					selectedPlane = p;					p.material.smooth = true;					p.removeEventListener(InteractiveScene3DEvent.OBJECT_PRESS, SelectPlane);					p.removeEventListener(InteractiveScene3DEvent.OBJECT_OVER, OverPlane);					p.removeEventListener(InteractiveScene3DEvent.OBJECT_OUT, OutPlane);					p.addEventListener(InteractiveScene3DEvent.OBJECT_PRESS, SelectPlane, false, 0, true);					// ------------------------------------------------------------------------------					// All not selected				} else if ( selectedID != rec._id  ) {					// && selectedID != -1 ){ // 5/12/09					p.removeEventListener(InteractiveScene3DEvent.OBJECT_PRESS, SelectPlane);					p.removeEventListener(InteractiveScene3DEvent.OBJECT_OVER, OverPlane);					p.removeEventListener(InteractiveScene3DEvent.OBJECT_OUT, OutPlane);					p.addEventListener(InteractiveScene3DEvent.OBJECT_OVER, OverPlane);					p.addEventListener(InteractiveScene3DEvent.OBJECT_OUT, OutPlane);				}				// ------------------------------------------------------------------------------				// Sin Extrusion				sinValue = Math.sin(currentSinDegs * Math.PI / 180)				sinZ = sinValue * _renderSettings.cycleExtrusion ;				// ------------------------------------------------------------------------------				// Positionals				tx = ( col * _renderSettings.gridXSpacing ) + _renderSettings.gridXOffset				ty = ( row * _renderSettings.gridYSpacing ) + _renderSettings.gridYOffset				tz = ( rec._id == sID && selectedID >= 0 ) ? _renderSettings.gridSelectedZ + sinZ : 0 + sinZ;				// ------------------------------------------------------------------------------				// Scale				if ( rec._id == sID && selectedID >= 0 ) {					ts = ( _renderSettings.cycleScaleMultiplier == 0 ) ? _renderSettings.gridSelectedScale : _renderSettings.gridSelectedScale * ( sinValue * _renderSettings.cycleScaleMultiplier );				} else {					ts = ( _renderSettings.cycleScaleMultiplier == 0 ) ? _renderSettings.gridScale : _renderSettings.gridScale * ( sinValue * _renderSettings.cycleScaleMultiplier );				}				// ------------------------------------------------------------------------------				// Alpha				ta = ( rec._id == sID ) ? _renderSettings.alphaSelected : _renderSettings.alpha;				// ------------------------------------------------------------------------------				// Position / Animate Plane				if ( invalidate ) {					// Position Plane without animation - animation invalidated					p.x = tx					p.y = ty					p.z = tz + p.extra.rZ;					p.scale = ts;					p.rotationX = 0;					p.rotationY = 0;					p.alpha = ta;				} else {					var callback : Function = (  selectedID == rec._id && selectedID != -1  ) ? AnimationComplete : null ;					// Animate Plane in place					TweenMax.to(p, tweenTime, {x:tx, y:ty, z:tz + p.extra.rZ, scale:ts, rotationX:0, rotationY:0, alpha:ta, delay:calcDelay, ease:easeFnc, onComplete:callback});				}				// Decrement Row Counter				row--;			}			initFlag = true;			prevrZ = _renderSettings.gridRandomZPosition;		}		/**		 * @method renderCamera( _camera : CameraObject3D , s : Stage = null ) : void		 * @tooltip		 * @param  		 */		override public function renderCamera(_camera : CameraObject3D, s : Stage = null) : void {			if ( _camera == null ) return;			if ( selectedPlane == null ) return;			if ( isNaN(selectedPlane.z)) return;			if ( !data.length > 2 ) return;			if ( s != null) {				stageWidth = s.width				stageHeight = s.height			}			// ------------------------------------------------------------------------------			// Initialize Camera			if ( !initCameraFlag ) {				targetDO = new DisplayObject3D();				// Create / Set target Display Object				targetDO.z = 1;				_camera.target = targetDO;				initCameraFlag = true;			}			var tz : Number			// ------------------------------------------------------------------------------			// Render Loop - No plane is selected			if ( s != null && selectedID == -1  ) {				midPoint = ( ( _renderSettings.gridYSpacing * _renderSettings.gridRows ) + _renderSettings.gridYOffset ) / 2;				tz = targetDO.z + (  selectedPlane.z - targetDO.z ) * _renderSettings.animationCameraTargetSpeed;				targetDO.x += (  unSelectedTargetXPos - targetDO.x ) * _renderSettings.animationCameraTargetSpeed;				targetDO.y += (  midPoint - targetDO.y ) * _renderSettings.animationCameraTargetSpeed;				targetDO.z = tz;				tz = _camera.z + (  selectedPlane.z - _camera.z + _renderSettings.cameraNotSelectedZOffset ) * _renderSettings.animationCameraSpeed;				_camera.x += (  unSelectedTargetXPos - _camera.x ) * _renderSettings.animationCameraSpeed;				_camera.y += (  midPoint - _camera.y ) * _renderSettings.animationCameraSpeed;				_camera.z = tz				// (  selectedPlane.z - _camera.z + _renderSettings.cameraNotSelectedZOffset ) * _renderSettings.animationCameraSpeed;				// ------------------------------------------------------------------------------				// Render Loop - Plane is selected			} else if ( selectedID != -1 && selectedPlane != null ) {				tz = targetDO.z + (  selectedPlane.z - targetDO.z ) * _renderSettings.animationCameraTargetSpeed;				if ( tz == 0 ) tz = 2;				targetDO.x += (  selectedPlane.x - targetDO.x ) * _renderSettings.animationCameraTargetSpeed;				targetDO.y += (  selectedPlane.y - targetDO.y ) * _renderSettings.animationCameraTargetSpeed;				targetDO.z = tz				tz = _camera.z + (  selectedPlane.z - _camera.z + _renderSettings.cameraSelectedZOffset ) * _renderSettings.animationCameraSpeed;				if ( tz == 0 ) tz = 1;				_camera.x += (  selectedPlane.x - _camera.x ) * _renderSettings.animationCameraSpeed;				_camera.y += (  selectedPlane.y - _camera.y ) * _renderSettings.animationCameraSpeed;				_camera.z = tz;			}		}		/**		 * @method 		 * @tooltip		 * @param  		 */		public function scrollStart(scrollMultiplier : int) : void {			_scrollMultiplier = scrollMultiplier;			_scrollTimer.start()			scrollLoop();		}		/**		 * @method 		 * @tooltip		 * @param  		 */		public function scrollStop() : void {			_scrollTimer.stop();		}		/**		 * @method 		 * @tooltip		 * @param  		 */		private function scrollLoop(t : TimerEvent = null) : void {			if ( unSelectedTargetXPos + _scrollMultiplier > data[data.length - 1 ].plane.x - stageWidth / 2 ) {				unSelectedTargetXPos = data[data.length - 1 ].plane.x - stageWidth / 2			} else if ( unSelectedTargetXPos + _scrollMultiplier < data[0 ].plane.x + stageWidth / 2 ) {				unSelectedTargetXPos = data[0].plane.x + stageWidth / 2 ;			} else {				unSelectedTargetXPos += _scrollMultiplier				// startDragXPos - xPos;			}			// TODO Screen values to stop screen Juddering			// startDragXPos = _scrollMultiplier//unSelectedTargetXPos + _scrollMultiplier;			// DragEvent( _scrollMultiplier , 0 )		}		// -GET/SET----------------------------------------------------------------------------------------------------------------------------------------------------		// ------------------------------------------------------------------------------------------------------------------------------------------------------------		//		// GGGGG  EEEEEEE TTTTTT          SSSSS EEEEEEE TTTTTT		// GG      EE        TT           SS     EE        TT		// GG  GGG EEEE      TT            SSSS  EEEE      TT		// GG   GG EE        TT               SS EE        TT		// GGGGG  EEEEEEE   TT           SSSSS  EEEEEEE   TT		//		// ------------------------------------------------------------------------------------------------------------------------------------------------------------		// ------------------------------------------------------------------------------------------------------------------------------------------------------------		/**		 * @method 		 * @tooltip		 * @param  		 */		override public function get isDeselected() : Boolean {			return false;		}		/**		 * @method setRenderData( a : Array ) : void		 * @tooltip		 * @param  		 */		override public function setRenderData(a : Array) : void {			data = a;		}		/**		 * @method setGallerySettings( settings : GallerySettings ) : void		 * @tooltip		 * @param  		 */		override public function setGallerySettings(settings : GallerySettings) : void {			_settings = settings;		}		/**		 * @method setRenderSettings( s : * ) : void		 * @tooltip		 * @param		 * @return		 */		override public function setRenderSettings(s : *) : void {			_renderSettings = s;			unSelectedTargetXPos = 0;		}		/**		 * @method etRenderSettings( ) : *		 * @tooltip		 * @param  		 */		override public function getRenderSettings() : * {			return _renderSettings		}		// -EVENT HANDLERS-------------------------------------------------------------------------------------------------------------------------------------------		// ------------------------------------------------------------------------------------------------------------------------------------------------------------		//		// EEEEEEE V     V EEEEEEE NN  NN TTTTTT         HH   HH   AAA   NN  NN DDDDDD  LL      EEEEEEE RRRRR    SSSSS		// EE      V     V EE      NNN NN   TT           HH   HH  AAAAA  NNN NN DD   DD LL      EE      RR  RR  SS		// EEEE     V   V  EEEE    NNNNNN   TT           HHHHHHH AA   AA NNNNNN DD   DD LL      EEEE    RRRRR    SSSS		// EE        V V   EE      NN NNN   TT           HH   HH AAAAAAA NN NNN DD   DD LL      EE      RR  RR      SS		// EEEEEEE    V    EEEEEEE NN  NN   TT           HH   HH AA   AA NN  NN DDDDDD  LLLLLLL EEEEEEE RR   RR SSSSS		//		// ------------------------------------------------------------------------------------------------------------------------------------------------------------		// ------------------------------------------------------------------------------------------------------------------------------------------------------------		/**		 * @method DragEvent( xPos : Number , yPos : Number )		 * @tooltip		 * @param  		 */		override public function DragEvent(xPos : Number, yPos : Number) : void {			// Drag event			if ( data.length > 1 ) {				if ( data[data.length - 1 ] == null ) return ;				if ( data[data.length - 1 ].plane == null ) return ;				if ( unSelectedTargetXPos + startDragXPos - xPos > data[data.length - 1 ].plane.x - stageWidth / 2 ) {					unSelectedTargetXPos = data[data.length - 1 ].plane.x - stageWidth / 2				} else if ( unSelectedTargetXPos + startDragXPos - xPos < data[0 ].plane.x + stageWidth / 2 ) {					unSelectedTargetXPos = data[0].plane.x + stageWidth / 2 ;				} else {					unSelectedTargetXPos += startDragXPos - xPos;				}			}		}		/**		 * @method MouseDownEvent( e : MouseEvent )		 * @tooltip		 * @param  		 */		override public function MouseDownEvent(e : MouseEvent) : void {			startDragXPos = e.stageX		}		/**		 * @method MouseUpEvent( e : MouseEvent )		 * @tooltip		 * @param  		 */		override public function MouseUpEvent(e : MouseEvent) : void {		}		/**		 * @method MouseMoveEvent( e : MouseEvent )		 * @tooltip		 * @param  		 */		override public function MouseMoveEvent(e : MouseEvent) : void {		}		/**		 * @method 		 * @tooltip		 * @param  		 */		private function OutPlane(e : InteractiveScene3DEvent) : void {			e.displayObject3D.alpha = _renderSettings.alpha;			/*			if ( e.displayObject3D.extra.isOver ){							e.displayObject3D.extra.isOver 	= false;			e.displayObject3D.z 			= 0 + e.displayObject3D.extra.rZ			e.displayObject3D.scale			= _renderSettings.gridScale;							}*/		}		/**		 * @method OverPlane( e : InteractiveScene3DEvent ) : void		 * @tooltip		 * @param  		 */		private function OverPlane(e : InteractiveScene3DEvent) : void {			e.displayObject3D.alpha = _renderSettings.alphaRollOver;			/*			// if ( selectedID == -1 ){							if ( prevRollOverPlane != null ){			var sI : InteractiveScene3DEvent =  new InteractiveScene3DEvent( InteractiveScene3DEvent.OBJECT_OUT )			sI.displayObject3D = prevRollOverPlane as DisplayObject3D;			OutPlane( sI );					 			}							e.displayObject3D.z 			= _renderSettings.rollOverZ			e.displayObject3D.scale			= _renderSettings.rollOverScale;			e.displayObject3D.extra.isOver 	= true;							prevRollOverPlane 				= e.displayObject3D as Plane			// }*/		}		/**		 * @method SelectPlane( e : InteractiveScene3DEvent ) : void		 * @tooltip		 * @param  		 */		private function SelectPlane(e : InteractiveScene3DEvent) : void {			if ( selectedID != -1 ) {				render(-1);			} else if ( selectedID < 0 ) {				render(Number(e.currentTarget.name));			}		}		/**		 * @method AnimationComplete( e : Event = null ) : void		 * @tooltip		 * @param  		 */		override public function AnimationComplete(e : Event = null) : void {			super.AnimationComplete();			var ge : Gallery3dEvent = new Gallery3dEvent(Gallery3dEvent.SCROLL_COMPLETE, true);			if ( selectedRecord != null )				ge.selectedID = selectedRecord._id;			if ( data != null )				ge.totalItems = data.length - 1;			dispatchEvent(ge);		}	}}